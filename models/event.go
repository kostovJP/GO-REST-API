package models

import (
	"time"

	"example.com/REST-API/db"
)

// any event must have these lables.
// we can use struct tags to enforce some of these labels (make them must be included in the
// request body)
type Event struct {
	ID          int64
	Name        string    `binding:"required"`
	Description string    `binding:"required"`
	Location    string    `binding:"required"`
	DateTime    time.Time `binding:"required"`
	UserId      int
}

func (evt Event) Save() error {
	// the query that we will use to insert the event into our table events.
	// using the ? method of inserting values is the safest one that
	// prevents sql injections.
	query := `
	INSERT INTO events (name, description, location, dateTime, user_id) 
	VALUES (?, ?, ?, ?, ?)`

	// gives us a prepared sql statement. Later we also have to
	// make sure to close the statement variable, after the job is done
	// in the function.
	// ----------------------------------------------
	// Using Prepare first instead of directly using exec() is faster sometimes.
	// Prepare essentially stores the statement in the memory and then it can
	// be reused in a highly efficient way.
	// It is advised to use Prepare() in case of complex queries.
	// But we will benefit from that only if we don't close the stmt.
	// Here we are closing it, as this is a simple enough query and
	// I am trying to learn the standard procedure of doing things.
	stmt, err := db.DB.Prepare(query)

	if err != nil {
		return err
	}

	//will execute stmt.Close() after the parent function has finished execution.
	defer stmt.Close()

	// Executes a prepared statement with the given arguments and returns a result
	// or an error if execution failed.
	//----------------------------------
	// Exec is used whenever there is a query that changes the data in a
	// database.
	result, err := stmt.Exec(
		evt.Name,
		evt.Description,
		evt.Location,
		evt.DateTime,
		evt.UserId,
	)

	if err != nil {
		return err
	}

	// LastInsertId returns the integer generated by the database
	// in response to a command.
	// Typically this will be from an "auto increment" column when inserting a new row
	id, err := result.LastInsertId()

	if err != nil {
		return err
	}

	evt.ID = id
	return nil
}

func GetAllEvents() ([]Event, error) {
	query := "SELECT * FROM events"

	// Unlike Exec(), Query() is used to xecutes a query that returns rows,
	// typically a SELECT. The args are for any placeholder parameters in the query.
	rows, err := db.DB.Query(query)

	if err != nil {
		return nil, err
	}

	defer rows.Close()
	var events []Event

	// rows.Next() returns true as long as there are more rows left to
	// iterate over.
	for rows.Next() {
		var event Event
		err := rows.Scan(
			&event.ID,
			&event.Name,
			&event.Description,
			&event.Location,
			&event.DateTime,
			&event.UserId,
		)

		if err != nil {
			return nil, err
		}

		events = append(events, event)
	}

	return events, nil
}

//getting an event By it's ID

func GetEventById(id int64) (*Event, error) {
	query := "SELECT * FROM events WHERE id = ?"

	// QueryRow() returns only one row. We are using this here because we know
	// that there will only be one event with that id.
	// The second argument is the one that will replace the ? in query..
	row := db.DB.QueryRow(query, id)

	var event Event

	//scans the content of that row into the event object.
	err := row.Scan(
		&event.ID,
		&event.Name,
		&event.Description,
		&event.Location,
		&event.DateTime,
		&event.UserId,
	)

	if err != nil {
		return nil, err
	}

	return &event, nil
}

func (event Event) Update() error {
	query := `
	UPDATE events
	SET name = ?, description = ?, location = ?, dateTime = ?
	WHERE id = ?`

	stmt, err := db.DB.Prepare(query)

	if err != nil {
		return err
	}

	defer stmt.Close()

	_ , err = stmt.Exec(
		event.Name,
		event.Description,
		event.Location,
		event.DateTime,
		event.ID,
	)

	return err
}

//Deletes an event from the database.
func (event Event) Delete() error {
	query := `DELETE FROM events WHERE id = ?`

	stmt, err := db.DB.Prepare(query)

	if err != nil {
		return err
	}

	defer stmt.Close()

	_, err = stmt.Exec(event.ID)
	return err
}
